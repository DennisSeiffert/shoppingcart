//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.5.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from ../voucher.g4 by ANTLR 4.5.1

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591

using System;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode ("ANTLR", "4.5.1")]
public partial class voucherParser : Parser
{
	public const int
		T__0 = 1, T__1 = 2, T__2 = 3, T__3 = 4, NEWLINE = 5, INT = 6, DECIMALSEPARATOR = 7;
	public const int
		RULE_voucher = 0, RULE_line = 1, RULE_price = 2;
	public static readonly string[] ruleNames = {
		"voucher", "line", "price"
	};

	private static readonly string[] _LiteralNames = {
		null, "'Summe'", "'SUMME'", "'Total'", "'TOTAL'"
	};
	private static readonly string[] _SymbolicNames = {
		null, null, null, null, null, "NEWLINE", "INT", "DECIMALSEPARATOR"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary (_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary {
		get {
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "voucher.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	public voucherParser (ITokenStream input)
		: base (input)
	{
		Interpreter = new ParserATNSimulator (this, _ATN);
	}

	public partial class VoucherContext : ParserRuleContext
	{
		public LineContext[] line ()
		{
			return GetRuleContexts<LineContext> ();
		}

		public LineContext line (int i)
		{
			return GetRuleContext<LineContext> (i);
		}

		public ITerminalNode[] NEWLINE ()
		{
			return GetTokens (voucherParser.NEWLINE);
		}

		public ITerminalNode NEWLINE (int i)
		{
			return GetToken (voucherParser.NEWLINE, i);
		}

		public VoucherContext (ParserRuleContext parent, int invokingState)
			: base (parent, invokingState)
		{
		}

		public override int RuleIndex { get { return RULE_voucher; } }

		public override void EnterRule (IParseTreeListener listener)
		{
			IvoucherListener typedListener = listener as IvoucherListener;
			if (typedListener != null)
				typedListener.EnterVoucher (this);
		}

		public override void ExitRule (IParseTreeListener listener)
		{
			IvoucherListener typedListener = listener as IvoucherListener;
			if (typedListener != null)
				typedListener.ExitVoucher (this);
		}
	}

	[RuleVersion (0)]
	public VoucherContext voucher ()
	{
		VoucherContext _localctx = new VoucherContext (Context, State);
		EnterRule (_localctx, 0, RULE_voucher);
		int _la;
		try {
			EnterOuterAlt (_localctx, 1);
			{
				State = 11;
				ErrorHandler.Sync (this);
				_la = TokenStream.La (1);
				while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << T__0) | (1L << T__1) | (1L << T__2) | (1L << T__3))) != 0)) {
					{
						{
							State = 6;
							line ();
							State = 7;
							Match (NEWLINE);
						}
					}
					State = 13;
					ErrorHandler.Sync (this);
					_la = TokenStream.La (1);
				}
			}
		} catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError (this, re);
			ErrorHandler.Recover (this, re);
		} finally {
			ExitRule ();
		}
		return _localctx;
	}

	public partial class LineContext : ParserRuleContext
	{
		public PriceContext price ()
		{
			return GetRuleContext<PriceContext> (0);
		}

		public LineContext (ParserRuleContext parent, int invokingState)
			: base (parent, invokingState)
		{
		}

		public override int RuleIndex { get { return RULE_line; } }

		public override void EnterRule (IParseTreeListener listener)
		{
			IvoucherListener typedListener = listener as IvoucherListener;
			if (typedListener != null)
				typedListener.EnterLine (this);
		}

		public override void ExitRule (IParseTreeListener listener)
		{
			IvoucherListener typedListener = listener as IvoucherListener;
			if (typedListener != null)
				typedListener.ExitLine (this);
		}
	}

	[RuleVersion (0)]
	public LineContext line ()
	{
		LineContext _localctx = new LineContext (Context, State);
		EnterRule (_localctx, 2, RULE_line);
		int _la;
		try {
			EnterOuterAlt (_localctx, 1);
			{
				State = 14;
				_la = TokenStream.La (1);
				if (!((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << T__0) | (1L << T__1) | (1L << T__2) | (1L << T__3))) != 0))) {
					ErrorHandler.RecoverInline (this);
				} else {
					Consume ();
				}
				State = 15;
				price ();
			}
		} catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError (this, re);
			ErrorHandler.Recover (this, re);
		} finally {
			ExitRule ();
		}
		return _localctx;
	}

	public partial class PriceContext : ParserRuleContext
	{
		public ITerminalNode[] INT ()
		{
			return GetTokens (voucherParser.INT);
		}

		public ITerminalNode INT (int i)
		{
			return GetToken (voucherParser.INT, i);
		}

		public ITerminalNode DECIMALSEPARATOR ()
		{
			return GetToken (voucherParser.DECIMALSEPARATOR, 0);
		}

		public PriceContext (ParserRuleContext parent, int invokingState)
			: base (parent, invokingState)
		{
		}

		public override int RuleIndex { get { return RULE_price; } }

		public override void EnterRule (IParseTreeListener listener)
		{
			IvoucherListener typedListener = listener as IvoucherListener;
			if (typedListener != null)
				typedListener.EnterPrice (this);
		}

		public override void ExitRule (IParseTreeListener listener)
		{
			IvoucherListener typedListener = listener as IvoucherListener;
			if (typedListener != null)
				typedListener.ExitPrice (this);
		}
	}

	[RuleVersion (0)]
	public PriceContext price ()
	{
		PriceContext _localctx = new PriceContext (Context, State);
		EnterRule (_localctx, 4, RULE_price);
		try {
			EnterOuterAlt (_localctx, 1);
			{
				State = 17;
				Match (INT);
				State = 18;
				Match (DECIMALSEPARATOR);
				State = 19;
				Match (INT);
			}
		} catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError (this, re);
			ErrorHandler.Recover (this, re);
		} finally {
			ExitRule ();
		}
		return _localctx;
	}

	public static readonly string _serializedATN =
		"\x3\x430\xD6D1\x8206\xAD2D\x4417\xAEF1\x8D80\xAADD\x3\t\x18\x4\x2\t\x2" +
		"\x4\x3\t\x3\x4\x4\t\x4\x3\x2\x3\x2\x3\x2\a\x2\f\n\x2\f\x2\xE\x2\xF\v\x2" +
		"\x3\x3\x3\x3\x3\x3\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x2\x2\x5\x2\x4\x6\x2" +
		"\x3\x3\x2\x3\x6\x15\x2\r\x3\x2\x2\x2\x4\x10\x3\x2\x2\x2\x6\x13\x3\x2\x2" +
		"\x2\b\t\x5\x4\x3\x2\t\n\a\a\x2\x2\n\f\x3\x2\x2\x2\v\b\x3\x2\x2\x2\f\xF" +
		"\x3\x2\x2\x2\r\v\x3\x2\x2\x2\r\xE\x3\x2\x2\x2\xE\x3\x3\x2\x2\x2\xF\r\x3" +
		"\x2\x2\x2\x10\x11\t\x2\x2\x2\x11\x12\x5\x6\x4\x2\x12\x5\x3\x2\x2\x2\x13" +
		"\x14\a\b\x2\x2\x14\x15\a\t\x2\x2\x15\x16\a\b\x2\x2\x16\a\x3\x2\x2\x2\x3" +
		"\r";
	public static readonly ATN _ATN =
		new ATNDeserializer ().Deserialize (_serializedATN.ToCharArray ());
}
